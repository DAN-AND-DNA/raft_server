// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api.proto

#ifndef PROTOBUF_api_2eproto__INCLUDED
#define PROTOBUF_api_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_api_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultshandshake_qImpl();
void InitDefaultshandshake_q();
void InitDefaultshandshake_rImpl();
void InitDefaultshandshake_r();
void InitDefaultsentryImpl();
void InitDefaultsentry();
void InitDefaultsappendentries_qImpl();
void InitDefaultsappendentries_q();
void InitDefaultsappendentries_rImpl();
void InitDefaultsappendentries_r();
inline void InitDefaults() {
  InitDefaultshandshake_q();
  InitDefaultshandshake_r();
  InitDefaultsentry();
  InitDefaultsappendentries_q();
  InitDefaultsappendentries_r();
}
}  // namespace protobuf_api_2eproto
namespace api {
class appendentries_q;
class appendentries_qDefaultTypeInternal;
extern appendentries_qDefaultTypeInternal _appendentries_q_default_instance_;
class appendentries_r;
class appendentries_rDefaultTypeInternal;
extern appendentries_rDefaultTypeInternal _appendentries_r_default_instance_;
class entry;
class entryDefaultTypeInternal;
extern entryDefaultTypeInternal _entry_default_instance_;
class handshake_q;
class handshake_qDefaultTypeInternal;
extern handshake_qDefaultTypeInternal _handshake_q_default_instance_;
class handshake_r;
class handshake_rDefaultTypeInternal;
extern handshake_rDefaultTypeInternal _handshake_r_default_instance_;
}  // namespace api
namespace api {

// ===================================================================

class handshake_q : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:api.handshake_q) */ {
 public:
  handshake_q();
  virtual ~handshake_q();

  handshake_q(const handshake_q& from);

  inline handshake_q& operator=(const handshake_q& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  handshake_q(handshake_q&& from) noexcept
    : handshake_q() {
    *this = ::std::move(from);
  }

  inline handshake_q& operator=(handshake_q&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const handshake_q& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const handshake_q* internal_default_instance() {
    return reinterpret_cast<const handshake_q*>(
               &_handshake_q_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(handshake_q* other);
  friend void swap(handshake_q& a, handshake_q& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline handshake_q* New() const PROTOBUF_FINAL { return New(NULL); }

  handshake_q* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const handshake_q& from);
  void MergeFrom(const handshake_q& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(handshake_q* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 raftport = 1;
  void clear_raftport();
  static const int kRaftportFieldNumber = 1;
  ::google::protobuf::uint32 raftport() const;
  void set_raftport(::google::protobuf::uint32 value);

  // uint32 httpport = 2;
  void clear_httpport();
  static const int kHttpportFieldNumber = 2;
  ::google::protobuf::uint32 httpport() const;
  void set_httpport(::google::protobuf::uint32 value);

  // uint32 nodeid = 3;
  void clear_nodeid();
  static const int kNodeidFieldNumber = 3;
  ::google::protobuf::uint32 nodeid() const;
  void set_nodeid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:api.handshake_q)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 raftport_;
  ::google::protobuf::uint32 httpport_;
  ::google::protobuf::uint32 nodeid_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2eproto::TableStruct;
  friend void ::protobuf_api_2eproto::InitDefaultshandshake_qImpl();
};
// -------------------------------------------------------------------

class handshake_r : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:api.handshake_r) */ {
 public:
  handshake_r();
  virtual ~handshake_r();

  handshake_r(const handshake_r& from);

  inline handshake_r& operator=(const handshake_r& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  handshake_r(handshake_r&& from) noexcept
    : handshake_r() {
    *this = ::std::move(from);
  }

  inline handshake_r& operator=(handshake_r&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const handshake_r& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const handshake_r* internal_default_instance() {
    return reinterpret_cast<const handshake_r*>(
               &_handshake_r_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(handshake_r* other);
  friend void swap(handshake_r& a, handshake_r& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline handshake_r* New() const PROTOBUF_FINAL { return New(NULL); }

  handshake_r* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const handshake_r& from);
  void MergeFrom(const handshake_r& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(handshake_r* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  bool result() const;
  void set_result(bool value);

  // @@protoc_insertion_point(class_scope:api.handshake_r)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool result_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2eproto::TableStruct;
  friend void ::protobuf_api_2eproto::InitDefaultshandshake_rImpl();
};
// -------------------------------------------------------------------

class entry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:api.entry) */ {
 public:
  entry();
  virtual ~entry();

  entry(const entry& from);

  inline entry& operator=(const entry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  entry(entry&& from) noexcept
    : entry() {
    *this = ::std::move(from);
  }

  inline entry& operator=(entry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const entry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const entry* internal_default_instance() {
    return reinterpret_cast<const entry*>(
               &_entry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(entry* other);
  friend void swap(entry& a, entry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline entry* New() const PROTOBUF_FINAL { return New(NULL); }

  entry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const entry& from);
  void MergeFrom(const entry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(entry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::uint32 term() const;
  void set_term(::google::protobuf::uint32 value);

  // uint32 write_it = 2;
  void clear_write_it();
  static const int kWriteItFieldNumber = 2;
  ::google::protobuf::uint32 write_it() const;
  void set_write_it(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:api.entry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 term_;
  ::google::protobuf::uint32 write_it_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2eproto::TableStruct;
  friend void ::protobuf_api_2eproto::InitDefaultsentryImpl();
};
// -------------------------------------------------------------------

class appendentries_q : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:api.appendentries_q) */ {
 public:
  appendentries_q();
  virtual ~appendentries_q();

  appendentries_q(const appendentries_q& from);

  inline appendentries_q& operator=(const appendentries_q& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  appendentries_q(appendentries_q&& from) noexcept
    : appendentries_q() {
    *this = ::std::move(from);
  }

  inline appendentries_q& operator=(appendentries_q&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const appendentries_q& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const appendentries_q* internal_default_instance() {
    return reinterpret_cast<const appendentries_q*>(
               &_appendentries_q_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(appendentries_q* other);
  friend void swap(appendentries_q& a, appendentries_q& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline appendentries_q* New() const PROTOBUF_FINAL { return New(NULL); }

  appendentries_q* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const appendentries_q& from);
  void MergeFrom(const appendentries_q& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(appendentries_q* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .api.entry entries = 5;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 5;
  const ::api::entry& entries(int index) const;
  ::api::entry* mutable_entries(int index);
  ::api::entry* add_entries();
  ::google::protobuf::RepeatedPtrField< ::api::entry >*
      mutable_entries();
  const ::google::protobuf::RepeatedPtrField< ::api::entry >&
      entries() const;

  // uint32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::uint32 term() const;
  void set_term(::google::protobuf::uint32 value);

  // uint32 prelogindex = 2;
  void clear_prelogindex();
  static const int kPrelogindexFieldNumber = 2;
  ::google::protobuf::uint32 prelogindex() const;
  void set_prelogindex(::google::protobuf::uint32 value);

  // uint32 prelogterm = 3;
  void clear_prelogterm();
  static const int kPrelogtermFieldNumber = 3;
  ::google::protobuf::uint32 prelogterm() const;
  void set_prelogterm(::google::protobuf::uint32 value);

  // uint32 leadercommit = 4;
  void clear_leadercommit();
  static const int kLeadercommitFieldNumber = 4;
  ::google::protobuf::uint32 leadercommit() const;
  void set_leadercommit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:api.appendentries_q)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::api::entry > entries_;
  ::google::protobuf::uint32 term_;
  ::google::protobuf::uint32 prelogindex_;
  ::google::protobuf::uint32 prelogterm_;
  ::google::protobuf::uint32 leadercommit_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2eproto::TableStruct;
  friend void ::protobuf_api_2eproto::InitDefaultsappendentries_qImpl();
};
// -------------------------------------------------------------------

class appendentries_r : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:api.appendentries_r) */ {
 public:
  appendentries_r();
  virtual ~appendentries_r();

  appendentries_r(const appendentries_r& from);

  inline appendentries_r& operator=(const appendentries_r& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  appendentries_r(appendentries_r&& from) noexcept
    : appendentries_r() {
    *this = ::std::move(from);
  }

  inline appendentries_r& operator=(appendentries_r&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const appendentries_r& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const appendentries_r* internal_default_instance() {
    return reinterpret_cast<const appendentries_r*>(
               &_appendentries_r_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(appendentries_r* other);
  friend void swap(appendentries_r& a, appendentries_r& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline appendentries_r* New() const PROTOBUF_FINAL { return New(NULL); }

  appendentries_r* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const appendentries_r& from);
  void MergeFrom(const appendentries_r& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(appendentries_r* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::uint32 term() const;
  void set_term(::google::protobuf::uint32 value);

  // bool success = 2;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // @@protoc_insertion_point(class_scope:api.appendentries_r)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 term_;
  bool success_;
  mutable int _cached_size_;
  friend struct ::protobuf_api_2eproto::TableStruct;
  friend void ::protobuf_api_2eproto::InitDefaultsappendentries_rImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// handshake_q

// uint32 raftport = 1;
inline void handshake_q::clear_raftport() {
  raftport_ = 0u;
}
inline ::google::protobuf::uint32 handshake_q::raftport() const {
  // @@protoc_insertion_point(field_get:api.handshake_q.raftport)
  return raftport_;
}
inline void handshake_q::set_raftport(::google::protobuf::uint32 value) {
  
  raftport_ = value;
  // @@protoc_insertion_point(field_set:api.handshake_q.raftport)
}

// uint32 httpport = 2;
inline void handshake_q::clear_httpport() {
  httpport_ = 0u;
}
inline ::google::protobuf::uint32 handshake_q::httpport() const {
  // @@protoc_insertion_point(field_get:api.handshake_q.httpport)
  return httpport_;
}
inline void handshake_q::set_httpport(::google::protobuf::uint32 value) {
  
  httpport_ = value;
  // @@protoc_insertion_point(field_set:api.handshake_q.httpport)
}

// uint32 nodeid = 3;
inline void handshake_q::clear_nodeid() {
  nodeid_ = 0u;
}
inline ::google::protobuf::uint32 handshake_q::nodeid() const {
  // @@protoc_insertion_point(field_get:api.handshake_q.nodeid)
  return nodeid_;
}
inline void handshake_q::set_nodeid(::google::protobuf::uint32 value) {
  
  nodeid_ = value;
  // @@protoc_insertion_point(field_set:api.handshake_q.nodeid)
}

// -------------------------------------------------------------------

// handshake_r

// bool result = 1;
inline void handshake_r::clear_result() {
  result_ = false;
}
inline bool handshake_r::result() const {
  // @@protoc_insertion_point(field_get:api.handshake_r.result)
  return result_;
}
inline void handshake_r::set_result(bool value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:api.handshake_r.result)
}

// -------------------------------------------------------------------

// entry

// uint32 term = 1;
inline void entry::clear_term() {
  term_ = 0u;
}
inline ::google::protobuf::uint32 entry::term() const {
  // @@protoc_insertion_point(field_get:api.entry.term)
  return term_;
}
inline void entry::set_term(::google::protobuf::uint32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:api.entry.term)
}

// uint32 write_it = 2;
inline void entry::clear_write_it() {
  write_it_ = 0u;
}
inline ::google::protobuf::uint32 entry::write_it() const {
  // @@protoc_insertion_point(field_get:api.entry.write_it)
  return write_it_;
}
inline void entry::set_write_it(::google::protobuf::uint32 value) {
  
  write_it_ = value;
  // @@protoc_insertion_point(field_set:api.entry.write_it)
}

// -------------------------------------------------------------------

// appendentries_q

// uint32 term = 1;
inline void appendentries_q::clear_term() {
  term_ = 0u;
}
inline ::google::protobuf::uint32 appendentries_q::term() const {
  // @@protoc_insertion_point(field_get:api.appendentries_q.term)
  return term_;
}
inline void appendentries_q::set_term(::google::protobuf::uint32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:api.appendentries_q.term)
}

// uint32 prelogindex = 2;
inline void appendentries_q::clear_prelogindex() {
  prelogindex_ = 0u;
}
inline ::google::protobuf::uint32 appendentries_q::prelogindex() const {
  // @@protoc_insertion_point(field_get:api.appendentries_q.prelogindex)
  return prelogindex_;
}
inline void appendentries_q::set_prelogindex(::google::protobuf::uint32 value) {
  
  prelogindex_ = value;
  // @@protoc_insertion_point(field_set:api.appendentries_q.prelogindex)
}

// uint32 prelogterm = 3;
inline void appendentries_q::clear_prelogterm() {
  prelogterm_ = 0u;
}
inline ::google::protobuf::uint32 appendentries_q::prelogterm() const {
  // @@protoc_insertion_point(field_get:api.appendentries_q.prelogterm)
  return prelogterm_;
}
inline void appendentries_q::set_prelogterm(::google::protobuf::uint32 value) {
  
  prelogterm_ = value;
  // @@protoc_insertion_point(field_set:api.appendentries_q.prelogterm)
}

// uint32 leadercommit = 4;
inline void appendentries_q::clear_leadercommit() {
  leadercommit_ = 0u;
}
inline ::google::protobuf::uint32 appendentries_q::leadercommit() const {
  // @@protoc_insertion_point(field_get:api.appendentries_q.leadercommit)
  return leadercommit_;
}
inline void appendentries_q::set_leadercommit(::google::protobuf::uint32 value) {
  
  leadercommit_ = value;
  // @@protoc_insertion_point(field_set:api.appendentries_q.leadercommit)
}

// repeated .api.entry entries = 5;
inline int appendentries_q::entries_size() const {
  return entries_.size();
}
inline void appendentries_q::clear_entries() {
  entries_.Clear();
}
inline const ::api::entry& appendentries_q::entries(int index) const {
  // @@protoc_insertion_point(field_get:api.appendentries_q.entries)
  return entries_.Get(index);
}
inline ::api::entry* appendentries_q::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:api.appendentries_q.entries)
  return entries_.Mutable(index);
}
inline ::api::entry* appendentries_q::add_entries() {
  // @@protoc_insertion_point(field_add:api.appendentries_q.entries)
  return entries_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::api::entry >*
appendentries_q::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:api.appendentries_q.entries)
  return &entries_;
}
inline const ::google::protobuf::RepeatedPtrField< ::api::entry >&
appendentries_q::entries() const {
  // @@protoc_insertion_point(field_list:api.appendentries_q.entries)
  return entries_;
}

// -------------------------------------------------------------------

// appendentries_r

// uint32 term = 1;
inline void appendentries_r::clear_term() {
  term_ = 0u;
}
inline ::google::protobuf::uint32 appendentries_r::term() const {
  // @@protoc_insertion_point(field_get:api.appendentries_r.term)
  return term_;
}
inline void appendentries_r::set_term(::google::protobuf::uint32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:api.appendentries_r.term)
}

// bool success = 2;
inline void appendentries_r::clear_success() {
  success_ = false;
}
inline bool appendentries_r::success() const {
  // @@protoc_insertion_point(field_get:api.appendentries_r.success)
  return success_;
}
inline void appendentries_r::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:api.appendentries_r.success)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace api

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_api_2eproto__INCLUDED
